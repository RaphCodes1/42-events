"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin-page/page",{

/***/ "(app-pages-browser)/./src/data/mockEvents.ts":
/*!********************************!*\
  !*** ./src/data/mockEvents.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchEvents: function() { return /* binding */ fetchEvents; },\n/* harmony export */   insertInitialData: function() { return /* binding */ insertInitialData; },\n/* harmony export */   mockEvents: function() { return /* binding */ mockEvents; }\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=format!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/format.mjs\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* harmony import */ var _store_eventsStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/eventsStore */ \"(app-pages-browser)/./src/store/eventsStore.ts\");\n/* __next_internal_client_entry_do_not_use__ mockEvents,insertInitialData,fetchEvents auto */ \n\n\n// Helper to create dates relative to today\nconst getRelativeDate = (dayOffset)=>{\n    const date = new Date();\n    date.setDate(date.getDate() + dayOffset);\n    return (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(date, \"yyyy-MM-dd'T'HH:mm:ss\");\n};\n// Default mock data for development\nconst defaultMockEvents = [];\nlet mockEvents = [\n    ...defaultMockEvents\n];\n// Function to insert initial data into the database\nconst insertInitialData = async ()=>{\n    console.log(\"Attempting to insert initial data...\");\n    try {\n        // First check if we already have data\n        const { data: existingData, error: checkError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"event_data\").select(\"id\").limit(1);\n        if (checkError) {\n            console.error(\"Error checking existing data:\", checkError);\n            return;\n        }\n        if (existingData && existingData.length > 0) {\n            console.log(\"Data already exists in database, skipping initial data insertion\");\n            return;\n        }\n        // Insert each mock event into the database\n        for (const event of defaultMockEvents){\n            const { error: insertError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"event_data\").insert({\n                title: event.title,\n                description: event.description,\n                date: event.date,\n                location: event.location,\n                category: event.category,\n                created_at: event.createdAt\n            });\n            if (insertError) {\n                console.error(\"Error inserting event:\", {\n                    event: event.title,\n                    error: insertError\n                });\n            } else {\n                console.log(\"Successfully inserted event:\", event.title);\n            }\n        }\n        console.log(\"Initial data insertion completed\");\n    } catch (error) {\n        console.error(\"Unexpected error during initial data insertion:\", error);\n    }\n};\nconst fetchEvents = async ()=>{\n    console.log(\"Starting fetchEvents...\");\n    try {\n        console.log(\"Attempting to fetch events from Supabase...\");\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"event_data\").select(\"*\");\n        if (error) {\n            console.error(\"Error fetching events from Supabase:\", {\n                error: error.message,\n                code: error.code,\n                details: error.details,\n                hint: error.hint\n            });\n            console.log(\"Falling back to mock data due to error\");\n            _store_eventsStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState().setEvents(mockEvents);\n            return;\n        }\n        var _data_length;\n        console.log(\"Supabase response received:\", {\n            dataLength: (_data_length = data === null || data === void 0 ? void 0 : data.length) !== null && _data_length !== void 0 ? _data_length : 0,\n            hasData: !!data,\n            firstEvent: (data === null || data === void 0 ? void 0 : data[0]) ? {\n                id: data[0].id,\n                title: data[0].title,\n                date: data[0].date\n            } : null\n        });\n        if (data && data.length > 0) {\n            console.log(\"Processing fetched events...\");\n            const events = data.map((event)=>({\n                    id: String(event.id),\n                    title: event.title,\n                    description: event.description,\n                    date: String(event.date),\n                    location: event.location,\n                    category: event.category,\n                    createdAt: String(event.created_at)\n                }));\n            console.log(\"Events processed successfully:\", {\n                totalEvents: events.length,\n                categories: [\n                    ...new Set(events.map((e)=>e.category))\n                ],\n                dateRange: {\n                    earliest: events.reduce((a, b)=>new Date(a.date) < new Date(b.date) ? a : b).date,\n                    latest: events.reduce((a, b)=>new Date(a.date) > new Date(b.date) ? a : b).date\n                }\n            });\n            mockEvents = events;\n            _store_eventsStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState().setEvents(events);\n            console.log(\"Events stored in state successfully\");\n        } else {\n            console.log(\"No events found in database, using mock data\");\n            _store_eventsStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState().setEvents(mockEvents);\n        }\n    } catch (error) {\n        console.error(\"Unexpected error in fetchEvents:\", {\n            error: error instanceof Error ? error.message : \"Unknown error\",\n            stack: error instanceof Error ? error.stack : undefined\n        });\n        console.log(\"Falling back to mock data due to unexpected error\");\n        _store_eventsStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState().setEvents(mockEvents);\n    }\n    console.log(\"fetchEvents completed\");\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9kYXRhL21vY2tFdmVudHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OzhGQUVrQztBQUNTO0FBQ087QUFFbEQsMkNBQTJDO0FBQzNDLE1BQU1HLGtCQUFrQixDQUFDQztJQUN2QixNQUFNQyxPQUFPLElBQUlDO0lBQ2pCRCxLQUFLRSxPQUFPLENBQUNGLEtBQUtHLE9BQU8sS0FBS0o7SUFDOUIsT0FBT0osOEVBQU1BLENBQUNLLE1BQU07QUFDdEI7QUFFQSxvQ0FBb0M7QUFDcEMsTUFBTUksb0JBQTZCLEVBNEJsQztBQUVNLElBQUlDLGFBQXNCO09BQUlEO0NBQWtCLENBQUM7QUFFeEQsb0RBQW9EO0FBQzdDLE1BQU1FLG9CQUFvQjtJQUMvQkMsUUFBUUMsR0FBRyxDQUFDO0lBQ1osSUFBSTtRQUNGLHNDQUFzQztRQUN0QyxNQUFNLEVBQUVDLE1BQU1DLFlBQVksRUFBRUMsT0FBT0MsVUFBVSxFQUFFLEdBQUcsTUFBTWhCLG1EQUFRQSxDQUM3RGlCLElBQUksQ0FBQyxjQUNMQyxNQUFNLENBQUMsTUFDUEMsS0FBSyxDQUFDO1FBRVQsSUFBSUgsWUFBWTtZQUNkTCxRQUFRSSxLQUFLLENBQUMsaUNBQWlDQztZQUMvQztRQUNGO1FBRUEsSUFBSUYsZ0JBQWdCQSxhQUFhTSxNQUFNLEdBQUcsR0FBRztZQUMzQ1QsUUFBUUMsR0FBRyxDQUFDO1lBQ1o7UUFDRjtRQUVBLDJDQUEyQztRQUMzQyxLQUFLLE1BQU1TLFNBQVNiLGtCQUFtQjtZQUNyQyxNQUFNLEVBQUVPLE9BQU9PLFdBQVcsRUFBRSxHQUFHLE1BQU10QixtREFBUUEsQ0FDMUNpQixJQUFJLENBQUMsY0FDTE0sTUFBTSxDQUFDO2dCQUNOQyxPQUFPSCxNQUFNRyxLQUFLO2dCQUNsQkMsYUFBYUosTUFBTUksV0FBVztnQkFDOUJyQixNQUFNaUIsTUFBTWpCLElBQUk7Z0JBQ2hCc0IsVUFBVUwsTUFBTUssUUFBUTtnQkFDeEJDLFVBQVVOLE1BQU1NLFFBQVE7Z0JB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R0FBRyxDQUFDO1FBQ2QsT0FBTztZQUNMRCxRQUFRQyxHQUFHLENBQUM7WUFDWlgsMERBQWNBLENBQUNrQyxRQUFRLEdBQUdDLFNBQVMsQ0FBQzNCO1FBQ3RDO0lBQ0YsRUFBRSxPQUFPTSxPQUFPO1FBQ2RKLFFBQVFJLEtBQUssQ0FBQyxvQ0FBb0M7WUFDaERBLE9BQU9BLGlCQUFpQnVDLFFBQVF2QyxNQUFNZ0IsT0FBTyxHQUFHO1lBQ2hEd0IsT0FBT3hDLGlCQUFpQnVDLFFBQVF2QyxNQUFNd0MsS0FBSyxHQUFHQztRQUNoRDtRQUNBN0MsUUFBUUMsR0FBRyxDQUFDO1FBQ1pYLDBEQUFjQSxDQUFDa0MsUUFBUSxHQUFHQyxTQUFTLENBQUMzQjtJQUN0QztJQUNBRSxRQUFRQyxHQUFHLENBQUM7QUFDZCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9kYXRhL21vY2tFdmVudHMudHM/M2M3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgeyBFdmVudCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ2RhdGUtZm5zJztcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnLi4vbGliL3N1cGFiYXNlJztcbmltcG9ydCB1c2VFdmVudHNTdG9yZSBmcm9tICcuLi9zdG9yZS9ldmVudHNTdG9yZSc7XG5cbi8vIEhlbHBlciB0byBjcmVhdGUgZGF0ZXMgcmVsYXRpdmUgdG8gdG9kYXlcbmNvbnN0IGdldFJlbGF0aXZlRGF0ZSA9IChkYXlPZmZzZXQ6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBkYXlPZmZzZXQpO1xuICByZXR1cm4gZm9ybWF0KGRhdGUsIFwieXl5eS1NTS1kZCdUJ0hIOm1tOnNzXCIpO1xufTtcblxuLy8gRGVmYXVsdCBtb2NrIGRhdGEgZm9yIGRldmVsb3BtZW50XG5jb25zdCBkZWZhdWx0TW9ja0V2ZW50czogRXZlbnRbXSA9IFtcbiAgLy8ge1xuICAvLyAgIGlkOiAnMScsXG4gIC8vICAgdGl0bGU6ICdXZWIgRGV2ZWxvcG1lbnQgV29ya3Nob3AnLFxuICAvLyAgIGRlc2NyaXB0aW9uOiAnTGVhcm4gdGhlIGxhdGVzdCB3ZWIgZGV2ZWxvcG1lbnQgdGVjaG5vbG9naWVzIGFuZCBiZXN0IHByYWN0aWNlcy4nLFxuICAvLyAgIGRhdGU6IGdldFJlbGF0aXZlRGF0ZSgyKSxcbiAgLy8gICBsb2NhdGlvbjogJ1RlY2ggSHViLCBSb29tIDEwMScsXG4gIC8vICAgY2F0ZWdvcnk6ICd3b3Jrc2hvcCcsXG4gIC8vICAgY3JlYXRlZEF0OiBnZXRSZWxhdGl2ZURhdGUoLTUpLFxuICAvLyB9LFxuICAvLyB7XG4gIC8vICAgaWQ6ICcyJyxcbiAgLy8gICB0aXRsZTogJ0FJIENvbmZlcmVuY2UgMjAyNCcsXG4gIC8vICAgZGVzY3JpcHRpb246ICdBbm51YWwgY29uZmVyZW5jZSBvbiBhcnRpZmljaWFsIGludGVsbGlnZW5jZSBhbmQgbWFjaGluZSBsZWFybmluZy4nLFxuICAvLyAgIGRhdGU6IGdldFJlbGF0aXZlRGF0ZSg3KSxcbiAgLy8gICBsb2NhdGlvbjogJ0NvbnZlbnRpb24gQ2VudGVyJyxcbiAgLy8gICBjYXRlZ29yeTogJ2NvbmZlcmVuY2UnLFxuICAvLyAgIGNyZWF0ZWRBdDogZ2V0UmVsYXRpdmVEYXRlKC0xMCksXG4gIC8vIH0sXG4gIC8vIHtcbiAgLy8gICBpZDogJzMnLFxuICAvLyAgIHRpdGxlOiAnU3RhcnR1cCBNZWV0dXAnLFxuICAvLyAgIGRlc2NyaXB0aW9uOiAnTmV0d29yayB3aXRoIGZlbGxvdyBlbnRyZXByZW5ldXJzIGFuZCBpbnZlc3RvcnMuJyxcbiAgLy8gICBkYXRlOiBnZXRSZWxhdGl2ZURhdGUoMyksXG4gIC8vICAgbG9jYXRpb246ICdJbm5vdmF0aW9uIFNwYWNlJyxcbiAgLy8gICBjYXRlZ29yeTogJ21lZXR1cCcsXG4gIC8vICAgY3JlYXRlZEF0OiBnZXRSZWxhdGl2ZURhdGUoLTMpLFxuICAvLyB9LFxuXTtcblxuZXhwb3J0IGxldCBtb2NrRXZlbnRzOiBFdmVudFtdID0gWy4uLmRlZmF1bHRNb2NrRXZlbnRzXTtcblxuLy8gRnVuY3Rpb24gdG8gaW5zZXJ0IGluaXRpYWwgZGF0YSBpbnRvIHRoZSBkYXRhYmFzZVxuZXhwb3J0IGNvbnN0IGluc2VydEluaXRpYWxEYXRhID0gYXN5bmMgKCkgPT4ge1xuICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byBpbnNlcnQgaW5pdGlhbCBkYXRhLi4uJyk7XG4gIHRyeSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIGRhdGFcbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nRGF0YSwgZXJyb3I6IGNoZWNrRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZXZlbnRfZGF0YScpXG4gICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAubGltaXQoMSk7XG5cbiAgICBpZiAoY2hlY2tFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgZXhpc3RpbmcgZGF0YTonLCBjaGVja0Vycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXhpc3RpbmdEYXRhICYmIGV4aXN0aW5nRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnRGF0YSBhbHJlYWR5IGV4aXN0cyBpbiBkYXRhYmFzZSwgc2tpcHBpbmcgaW5pdGlhbCBkYXRhIGluc2VydGlvbicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluc2VydCBlYWNoIG1vY2sgZXZlbnQgaW50byB0aGUgZGF0YWJhc2VcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGRlZmF1bHRNb2NrRXZlbnRzKSB7XG4gICAgICBjb25zdCB7IGVycm9yOiBpbnNlcnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2V2ZW50X2RhdGEnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICB0aXRsZTogZXZlbnQudGl0bGUsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGV2ZW50LmRlc2NyaXB0aW9uLFxuICAgICAgICAgIGRhdGU6IGV2ZW50LmRhdGUsXG4gICAgICAgICAgbG9jYXRpb246IGV2ZW50LmxvY2F0aW9uLFxuICAgICAgICAgIGNhdGVnb3J5OiBldmVudC5jYXRlZ29yeSxcbiAgICAgICAgICBjcmVhdGVkX2F0OiBldmVudC5jcmVhdGVkQXRcbiAgICAgICAgfSk7XG5cbiAgICAgIGlmIChpbnNlcnRFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbnNlcnRpbmcgZXZlbnQ6Jywge1xuICAgICAgICAgIGV2ZW50OiBldmVudC50aXRsZSxcbiAgICAgICAgICBlcnJvcjogaW5zZXJ0RXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IGluc2VydGVkIGV2ZW50OicsIGV2ZW50LnRpdGxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coJ0luaXRpYWwgZGF0YSBpbnNlcnRpb24gY29tcGxldGVkJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBlcnJvciBkdXJpbmcgaW5pdGlhbCBkYXRhIGluc2VydGlvbjonLCBlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBmZXRjaEV2ZW50cyA9IGFzeW5jICgpID0+IHtcbiAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIGZldGNoRXZlbnRzLi4uJyk7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gZmV0Y2ggZXZlbnRzIGZyb20gU3VwYWJhc2UuLi4nKTtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2V2ZW50X2RhdGEnKVxuICAgICAgLnNlbGVjdCgnKicpO1xuICAgICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBldmVudHMgZnJvbSBTdXBhYmFzZTonLCB7XG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzLFxuICAgICAgICBoaW50OiBlcnJvci5oaW50XG4gICAgICB9KTtcbiAgICAgIGNvbnNvbGUubG9nKCdGYWxsaW5nIGJhY2sgdG8gbW9jayBkYXRhIGR1ZSB0byBlcnJvcicpO1xuICAgICAgdXNlRXZlbnRzU3RvcmUuZ2V0U3RhdGUoKS5zZXRFdmVudHMobW9ja0V2ZW50cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1N1cGFiYXNlIHJlc3BvbnNlIHJlY2VpdmVkOicsIHtcbiAgICAgIGRhdGFMZW5ndGg6IGRhdGE/Lmxlbmd0aCA/PyAwLFxuICAgICAgaGFzRGF0YTogISFkYXRhLFxuICAgICAgZmlyc3RFdmVudDogZGF0YT8uWzBdID8ge1xuICAgICAgICBpZDogZGF0YVswXS5pZCxcbiAgICAgICAgdGl0bGU6IGRhdGFbMF0udGl0bGUsXG4gICAgICAgIGRhdGU6IGRhdGFbMF0uZGF0ZVxuICAgICAgfSA6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coJ1Byb2Nlc3NpbmcgZmV0Y2hlZCBldmVudHMuLi4nKTtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGRhdGEubWFwKChldmVudCk6IEV2ZW50ID0+ICh7XG4gICAgICAgIGlkOiBTdHJpbmcoZXZlbnQuaWQpLFxuICAgICAgICB0aXRsZTogZXZlbnQudGl0bGUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBldmVudC5kZXNjcmlwdGlvbixcbiAgICAgICAgZGF0ZTogU3RyaW5nKGV2ZW50LmRhdGUpLFxuICAgICAgICBsb2NhdGlvbjogZXZlbnQubG9jYXRpb24sXG4gICAgICAgIGNhdGVnb3J5OiBldmVudC5jYXRlZ29yeSxcbiAgICAgICAgY3JlYXRlZEF0OiBTdHJpbmcoZXZlbnQuY3JlYXRlZF9hdCksXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdFdmVudHMgcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseTonLCB7XG4gICAgICAgIHRvdGFsRXZlbnRzOiBldmVudHMubGVuZ3RoLFxuICAgICAgICBjYXRlZ29yaWVzOiBbLi4ubmV3IFNldChldmVudHMubWFwKGUgPT4gZS5jYXRlZ29yeSkpXSxcbiAgICAgICAgZGF0ZVJhbmdlOiB7XG4gICAgICAgICAgZWFybGllc3Q6IGV2ZW50cy5yZWR1Y2UoKGEsIGIpID0+IG5ldyBEYXRlKGEuZGF0ZSkgPCBuZXcgRGF0ZShiLmRhdGUpID8gYSA6IGIpLmRhdGUsXG4gICAgICAgICAgbGF0ZXN0OiBldmVudHMucmVkdWNlKChhLCBiKSA9PiBuZXcgRGF0ZShhLmRhdGUpID4gbmV3IERhdGUoYi5kYXRlKSA/IGEgOiBiKS5kYXRlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBtb2NrRXZlbnRzID0gZXZlbnRzO1xuICAgICAgdXNlRXZlbnRzU3RvcmUuZ2V0U3RhdGUoKS5zZXRFdmVudHMoZXZlbnRzKTtcbiAgICAgIGNvbnNvbGUubG9nKCdFdmVudHMgc3RvcmVkIGluIHN0YXRlIHN1Y2Nlc3NmdWxseScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnTm8gZXZlbnRzIGZvdW5kIGluIGRhdGFiYXNlLCB1c2luZyBtb2NrIGRhdGEnKTtcbiAgICAgIHVzZUV2ZW50c1N0b3JlLmdldFN0YXRlKCkuc2V0RXZlbnRzKG1vY2tFdmVudHMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGluIGZldGNoRXZlbnRzOicsIHtcbiAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyxcbiAgICAgIHN0YWNrOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZygnRmFsbGluZyBiYWNrIHRvIG1vY2sgZGF0YSBkdWUgdG8gdW5leHBlY3RlZCBlcnJvcicpO1xuICAgIHVzZUV2ZW50c1N0b3JlLmdldFN0YXRlKCkuc2V0RXZlbnRzKG1vY2tFdmVudHMpO1xuICB9XG4gIGNvbnNvbGUubG9nKCdmZXRjaEV2ZW50cyBjb21wbGV0ZWQnKTtcbn07XG4iXSwibmFtZXMiOlsiZm9ybWF0Iiwic3VwYWJhc2UiLCJ1c2VFdmVudHNTdG9yZSIsImdldFJlbGF0aXZlRGF0ZSIsImRheU9mZnNldCIsImRhdGUiLCJEYXRlIiwic2V0RGF0ZSIsImdldERhdGUiLCJkZWZhdWx0TW9ja0V2ZW50cyIsIm1vY2tFdmVudHMiLCJpbnNlcnRJbml0aWFsRGF0YSIsImNvbnNvbGUiLCJsb2ciLCJkYXRhIiwiZXhpc3RpbmdEYXRhIiwiZXJyb3IiLCJjaGVja0Vycm9yIiwiZnJvbSIsInNlbGVjdCIsImxpbWl0IiwibGVuZ3RoIiwiZXZlbnQiLCJpbnNlcnRFcnJvciIsImluc2VydCIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJsb2NhdGlvbiIsImNhdGVnb3J5IiwiY3JlYXRlZF9hdCIsImNyZWF0ZWRBdCIsImZldGNoRXZlbnRzIiwibWVzc2FnZSIsImNvZGUiLCJkZXRhaWxzIiwiaGludCIsImdldFN0YXRlIiwic2V0RXZlbnRzIiwiZGF0YUxlbmd0aCIsImhhc0RhdGEiLCJmaXJzdEV2ZW50IiwiaWQiLCJldmVudHMiLCJtYXAiLCJTdHJpbmciLCJ0b3RhbEV2ZW50cyIsImNhdGVnb3JpZXMiLCJTZXQiLCJlIiwiZGF0ZVJhbmdlIiwiZWFybGllc3QiLCJyZWR1Y2UiLCJhIiwiYiIsImxhdGVzdCIsIkVycm9yIiwic3RhY2siLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/data/mockEvents.ts\n"));

/***/ })

});